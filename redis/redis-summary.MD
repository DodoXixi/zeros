# redis总结

- **[redis基础](#redis基础)**
    - ***[redis支持的各种对象和数据结构](#redis支持的各种对象和数据结构)***
    - ***[RDB与AOF持久化](#RDB与AOF持久化)***
    - ***[过期键淘汰处理](#过期键淘汰处理)***
    - ***[功能之发布与订阅-subscribe](#功能之发布与订阅-subscribe)***
    - ***[redis事务的实现](#redis事务的实现)***   
    - ***[多机数据库的实现-复制,Sentinel与集群](#多机数据库的实现)***
    - ***[跳跃表 压缩列表](#跳跃表和压缩列表)***
    - ***[字典（哈希算法，键冲突）](#字典)***
    - ***[内存回收和对象共享](#内存回收和对象共享)***
    
- **[redis常见面试题](#redis常见面试问题)**
    - ***[Redis有哪几种数据淘汰策略](#Redis有哪几种数据淘汰策略)***
    - ***[一个字符串类型的值能存储最大容量是多少？](#一个字符串类型的值能存储最大容量是多少)***
    - ***[MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？](#如何保证redis中的数据都是热点数据)***
    - ***[说说Redis哈希槽的概念](#说说Redis哈希槽的概念)***
    - ***[Redis集群会有写操作丢失吗？为什么？](#Redis集群会有写操作丢失吗)***
    - ***[Redis中的管道有什么用？](#Redis中的管道有什么用)***
    - ***[Redis如何做内存优化？](#Redis如何做内存优化)***
    - ***[Redis回收进程如何工作的？](#Redis回收进程如何工作的)***
    - ***[Redis如何设计消息队列](#Redis如何设计消息队列)***
    - ***[Redis为什么使用单进程单线程方式也这么快](#Redis为什么使用单进程单线程方式也这么快)***
- **[redis涉及的名词](#redis涉及的名词)**

## redis基础
>redis是一个开源的,内存中的数据结构存储系统,它可以用作数据库,缓存和消息中间件。
特点：单进程,单线程,典型的KV数据库。支持多种类型的数据结构,如 字符串(strings),散列(hashes),集合(sets),
有序集合(sorted sets)与范围查询,bitmaps,hyperloglogs和地理空间(geospatial)索引半径查询。Redis内置了复制(replication),LUA脚本(Lua scripting)
LRU驱动时间(LRU eviction),事务(transactions)和不同级别的磁盘持久化(persistence),并通过Redis哨兵(Sentinel)和自动分区(cluster)提供高可用性(high availability)

### redis支持的各种对象和数据结构

* 字符串(Strings) ,一个字符串类型的值最多能存储512M字节的内容
* 列表(lists),简单的字符串列表，按照插入顺序排序。LPUSH 插入一个新元素到列表头部，RPUSH插入一个新元素到列表的尾部。
* 有序列表(Sorted sets),每个字符串元素都关联一个score,里面的元素总是通过scored进行排序。
* 散列（hashes）
* bit maps, 
* hyperloglogs, 用来做基数统计
    - PFADD: 指定元素添加到HyperLogLog中，
    - PFCOUNT：返回给定的HyperLogLog中的基数。
    - PFMERGE：合并多个HyperLogLog。
    
### RDB与AOF持久化
[Redis 持久化中文官网](http://www.redis.cn/topics/persistence.html)

****redis 提供了多种不同级别的持久化方式，一种为RDB，一种为AOF****
* RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.
* AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.
* 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
* 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.

****RDB 优缺点****

优点：
* 保存某个时间点得数据集适合用于备份
* 文件紧凑,方便传输,适合用于灾难恢复
* 执行的过程中，分出子进程操作，不影响主流程，可以优化redis性能。
* 与AOF相比，在恢复大的数据集的时候，RDB更快。
缺点:
* 由于是间隔时间执行，在出现redis意外停止工作的时候肯定会导致一部分数据丢失。
* RDB需要经常fork子进程来保存数据集到硬盘，当数据集比较大的时候，fork会非常耗时。

****AOF 优缺点****

优点：
* 可以选择多种不同的fsync策略
* AOF文件是一种只进行追加的日志文件
* Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写

缺点：
* 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
* 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB ,关闭fsync策略之后，AOF和RDB一样快。

***fsync策略***

* 每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全
* 每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。
* 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。

### 过期键淘汰处理

过期键淘汰策略分为 主动淘汰和被动淘汰
* **主动淘汰** 在key被访问的时候会判断这个key是否过期，如果过期，执行Del操作。
* **被动淘汰** 每秒执行十次
    - 测试随机的20个keys进行相关过期检测
    - 删除所有已经过期的keys
    - 如果有多于25%的keys过期，重复上述步骤
    
### 功能之发布与订阅-subscribe

redis支持发布订阅功能,命令主要有：

### redis事务的实现
redis通过MUTLTI，EXEC，WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会终端事务而改去执行其他客户端的命令请求，他会将事务中的所有命令都执行完毕，然后采取处理其他客户端的命令请求。

特点：redis事务不支持回滚,即使事务队列中的命令是执行错误的，也会执行下去，直到事务队列中的命令一直执行完。

***ACID***：
- **持久性**：redis服务器在无持久化的内存模式下运作时，以及服务器不再RDB持久化模式下运作时，在AOF下appendfsync选项为everysec和no时，事务不具有耐久性，
        当服务器在AOF持久化模式下，并且appendfsync选项为always时，事务具有耐久性。
- **隔离性**：redis是使用单线程的方式来执行事务导致redis的事务都是串行方式执行,因此总是具有隔离性。
- **原子性**：不支持混滚但是碰到错误会一直执行下去。
- **一致性**：

***WATCH***

带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，

***watched_keys***

### 多机数据库的实现

复制,Sentinel与集群

### 跳跃表和压缩列表

### 字典

哈希算法，键冲突
    
### 内存回收和对象共享

## redis常见面试问题：

### Redis有哪几种数据淘汰策略

### 一个字符串类型的值能存储最大容量是多少

### 如何保证redis中的数据都是热点数据

MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？

答：redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

### Redis有哪些适合的场景？

- ***[会话缓存(Session Cache)]***
- ***全页缓存(FPC)***
- ***[Redis如何设计消息队列](#Redis如何设计消息队列)***
- ***排行榜/计数器***
- ***发布/订阅***

### 说说Redis哈希槽的概念？

### Redis集群会有写操作丢失吗

Redis集群会有写操作丢失吗？为什么？

### Redis中的管道有什么用？

### Redis如何做内存优化？

### Redis回收进程如何工作的？

### Redis如何设计消息队列

普通队列:一般使用list结构作为队列，rpush生产消息，lpop消费消息,blpop阻塞消费。

消费多次：生产一次消费多次的情况使用发布/订阅模式

延时队列:使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理

### Redis为什么使用单进程单线程方式也这么快

- ***完全基于内存***
- ***数据结构简单,对数据操作也简单***
- ***使用多路I/O复用模型***

### 如果有大量的key需要设置同一时间过期，一般需要注意什么？

## redis涉及的名词： 
- ***缓存雪崩***
- ***缓存击穿***
- ***缓存预热***
   一般都是在活动开启之前，把热点数据放到redis中，做到一个提前预防的作用。
- ***缓存更新***
   DB中的数据改动后，为了保持数据的一致性，将数据同步到redis中一份。
- ***缓存降级***
- ***缓存热点数据***
热点key缓存失效重建缓存时，大量访问进来，造成并发问题。

两种解决方式：1.在程序中利用互斥锁实现或在redis中利用nx获取分布式锁，造成该代码块只能在同一时间被同一线程执行。
           2.不设置超时时间，永远有效(这种情况用的比较少，一般会造成数据不一致)

参照：https://cloud.tencent.com/developer/article/1409260

### 注释：
内容来源于[redis中文网](http://www.redis.cn/)